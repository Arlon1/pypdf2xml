#!/usr/bin/python
# *-* coding: utf-8 *-*
import csv
import re
import sys
import urllib
import HTMLParser
import argparse

from StringIO import StringIO
import lxml.etree, lxml.html
from pprint import pprint as pprint_orig

def pprint(obj, *args, **kwargs):
    width = kwargs.pop('width', 120)
    pprint_orig(obj, *args, width=width, **kwargs)

def xml2lines(filename):
    h = HTMLParser.HTMLParser()

    pdfxml = open(filename, 'r').read()
    root = lxml.etree.fromstring(pdfxml)

    fontspecs = { }
    rows = [ ]

    # first create lines from given XML
    for pagenum, page in enumerate(root):
        assert page.tag == 'page'
        pagelines = {}
        pwidth = page.attrib['width']
        pheight = page.attrib['height']
        for v in page:
            if v.tag == 'text':
                left = int(v.attrib.get('left'))
                top  = int(v.attrib.get('top'))
                # fix some off-by-one placement issues, which make some text span over two lines where it should be in one
                if pagelines.has_key(top-1):
                    top = top - 1
                elif pagelines.has_key(top+1):
                    top = top + 1
                line = pagelines.setdefault(top, [])
                line.append((left, v.text))
        ordered = list(sorted([(k, sorted(v)) for k,v in pagelines.iteritems()]))
        rows.extend(ordered)

    return rows

def lines2cols(rows, splits, header=-1, footer=-1, verbose=False):
    records = []
    # splits must containt catchall zero
    if 0 not in [i[0] for i in splits]:
        splits = [(0, 'left')] + splits
    splits = list(sorted(splits))
    
    for topoffset, line in rows:
        if footer != -1 and topoffset > footer:
            continue
        if header != -1 and topoffset < header:
            continue
        linerec = [[] for i in xrange(len(splits))]
        idx = len(splits)-1
        split = splits[idx]
        
        for left, text in sorted(line, reverse=True):
            while splits[idx][0] > left:
                idx = idx - 1
            linerec[idx].insert(0, (left, text))
        if verbose:
            print linerec

        records.append(linerec)
    return records

def records2csv(csv_filename, csv_sep):
    csvfd = open(csv_filename, 'wb')
    csvw = csv.writer(csvfd)
    for row in table:
        row2 = []
        for r in row:
            row2.append(csv_sep.join([i[1]['text'] for i in r]))
        csvw.writerow([i.encode('utf-8') for i in row2])
    csvfd.close()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Parse PDF XML into a CSV')
    parser.add_argument('filename', metavar='filename.pdf', type=str, nargs=1, help='input PDF')
    parser.add_argument('--verbose', dest='verbose', action='store_true', default=False, help='verbose output')
    parser.add_argument('--header', dest='header', type=int, nargs='?', default=-1, help='exclude all content on each page above this')
    parser.add_argument('--footer', dest='footer', type=int, nargs='?', default=-1, help='exclude all content on each page below this')
    parser.add_argument('--left', dest='left', type=str, nargs='?', help='position of a new cell split')
    parser.add_argument('--csv', dest='output', type=str, nargs='?', help='output CSV file name')
    parser.add_argument('--csv-textbox-separator', dest='csv_sep', type=str, default=u' ', nargs='?', help='output CSV separator for joining PDF TextBox elements')

    args = parser.parse_args()
    verbose = args.verbose
    if args.left:
        leftsplits = list(sorted([(int(i.strip()), 'left') for i in args.left.split(',')]))
    else:
        leftsplits = [(0, 'left')]
    
    rows = xml2lines(args.filename[0])
    table = lines2cols(rows,
        header=args.header,
        footer=args.footer,
        splits=leftsplits,
        verbose=verbose)
    
    if args.output:
        records2csv(args.output, args.csv_sep)
    
    #[(500, 'left'), (96, 'left'), (89, 'left'), (82, 'left'), (76, 'left'), (74, 'left'), (64, 'left'), (66, 'left'),])
